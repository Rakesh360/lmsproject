from django.db import models

# Create your models here.
from django.utils import timezone
from django.contrib.auth.models import AbstractUser
from django.db.models.signals import post_save, pre_delete
from django.dispatch import receiver
from django.conf import settings

from EasyHireApp.constants import *
from ckeditor.fields import RichTextField

import pytz
import re
import random
import datetime
import json
import math
import uuid
import logging

logger = logging.getLogger(__name__)

class User(AbstractUser):

    role = models.CharField(max_length=1,
                            null=False,
                            blank=False,
                            choices=USER_CHOICES)

    def name(self):
        return self.first_name + ' ' + self.last_name

class Institute(models.Model):

    name = models.CharField(max_length=1000, null=False, blank=False)

    is_activated = models.BooleanField(default=True)

    def __str__(self):
        return self.name

    class Meta:
        verbose_name = 'Institute'
        verbose_name_plural = 'Institutes'

class Stream(models.Model):

    name = models.CharField(max_length=100, null=False, blank=False)

    def __str__(self):
        return self.name

    class Meta:
        verbose_name = 'Stream'
        verbose_name_plural = 'Streams'

class IdentityProof(models.Model):

    document_name = models.CharField(max_length=100)

    def __str__(self):
        return self.document_name

    class Meta:
        verbose_name = 'IdentityProof'
        verbose_name_plural = 'IdentityProof'

class Administrator(User):

    administrator_id = models.CharField(unique=True, max_length=200, null=False, blank=False)

    def __init__(self, *args, **kwargs):
        super(User, self).__init__(*args, **kwargs)
        self.role = ADMINISTRATOR_ROLE

    def save(self, *args, **kwargs):
        if self.pk == None:
            self.set_password(self.password)
        super(User, self).save(*args, **kwargs)

    def delete(self, *args, **kwargs):
        super(User, self).delete(*args, **kwargs)

    class Meta:
        verbose_name = 'Administrator'
        verbose_name_plural = 'Administrator'


class Applicant(User):

    applicant_id = models.CharField(max_length=100, null=False, blank=False)

    category = models.CharField(max_length=100, null=True, blank=True, choices=APPLICANT_CATEGORY)

    image = models.ImageField(upload_to="pics", null=True, blank=True)

    name = models.CharField(max_length=100, null=True, blank=True)

    email_id = models.EmailField(max_length=256, null=False, blank=False)

    phone_number = models.CharField(max_length=10, null=False, blank=False)

    dob = models.DateField(auto_now=False, null=True, blank=True)

    college_name = models.ForeignKey(Institute, null=True, blank=True, on_delete=models.SET_NULL)

    year_of_passing = models.CharField(max_length=4, null=True, blank=True)

    stream = models.ForeignKey(Stream, null=True, blank=True, on_delete=models.SET_NULL)

    percentage = models.FloatField(default=0, null=True, blank=True)

    is_registered = models.BooleanField(default=False)

    is_approved = models.BooleanField(default=False)

    is_selected = models.BooleanField(default=False)

    is_rejected = models.BooleanField(default=False)

    status = models.CharField(max_length=1,
                              null=True,
                              blank=True,
                              choices=APPLICANT_APPLICATION_STATUS)

    resume = models.FileField(upload_to="resumes", null=True, blank=True)

    uuid = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)

    type_of_id_proof = models.ForeignKey(IdentityProof,
                                         null=True, blank=True, on_delete=models.SET_NULL)

    def get_current_status(self):
        if self.status == None:
            return "No round assigned"

        current_status = "None"
        try:
            if self.status == APPLICANT_AT_QUIZ:
                if self.is_quiz_ended():
                    logger.info("Quiz Ended")
                    quiz_score = self.get_last_attempted_quiz_score()
                    current_status = "Quiz Completed - Score: "+str(quiz_score)
                else:
                    current_status = "Quiz Assigned"
            elif self.status == APPLICANT_INTERVIEW:
                current_status = "Interview"
        except Exception as e:
            logger.error(e)
        logger.info("Current Status %s",current_status)
        return current_status

    def get_assigned_quiz_status(self):
        quiz_status = None
        try:
            quiz_status = QuizStatus.objects.filter(
                applicant=self).order_by('-pk')[0]
        except Exception as e:
            logger.info(e)

        return quiz_status

    def is_quiz_ended(self):
        quiz_status = self.get_assigned_quiz_status()
        logger.info("Status %s",quiz_status)
        assigned_quiz = quiz_status.quiz
        available_section_objs = QuizSection.objects.filter(quiz=assigned_quiz)
        completed_section_counter = 0
        for quiz_section in available_section_objs:
            try:
                quiz_section_result_obj = QuizSectionResult.objects.get(applicant=self,
                                                                        quiz_section=quiz_section)
                if quiz_section_result_obj.is_completed:
                    completed_section_counter += 1
            except Exception as e:
                pass
        logger.info(completed_section_counter)
        logger.info(available_section_objs)
        if completed_section_counter == len(available_section_objs):
            return True
        else:
            return False

    def get_last_attempted_quiz_score(self):
        last_attempted_quiz_status = self.get_assigned_quiz_status()
        logger.info(last_attempted_quiz_status)
        if last_attempted_quiz_status == None:
            return

        quiz_result_obj = QuizResult.objects.get(applicant=self,
                                                 quiz=last_attempted_quiz_status.quiz)
        logger.info(quiz_result_obj)
        return quiz_result_obj.get_applicant_score()

    def get_list_of_attempted_quiz(self):
        quiz_status_objs = QuizStatus.objects.filter(applicant=self)
        return quiz_status_objs

    def clear_attempted_quiz(self, quiz):
        ProblemAttempted.objects.filter(
            applicant=self, quiz_section__quiz=quiz).delete()
        QuizSectionResult.objects.filter(
            applicant=self, quiz_section__quiz=quiz).delete()
        QuizResult.objects.filter(applicant=self, quiz=quiz).delete()

    def reset_account(self):
        ProblemAttempted.objects.filter(applicant=self).delete()
        QuizSectionResult.objects.filter(applicant=self).delete()
        QuizStatus.objects.filter(applicant=self).delete()
        QuizResult.objects.filter(applicant=self).delete()
        self.status = None
        self.is_selected = False
        self.is_rejected = False
        self.save()

    def __init__(self, *args, **kwargs):
        super(User, self).__init__(*args, **kwargs)
        self.role = APPLICANT_ROLE

    def save(self, *args, **kwargs):
        if self.pk == None:
            self.set_password(self.password)
        super(User, self).save(*args, **kwargs)

    def delete(self, *args, **kwargs):
        super(User, self).delete(*args, **kwargs)

    def __str__(self):
        return self.name

    class Meta:
        verbose_name = 'Applicant'
        verbose_name_plural = 'Applicant'



class AppConfig(models.Model):

    is_quiz_activated = models.BooleanField(default=False)

    is_id_proof_required = models.BooleanField(default=True)

    is_employment_declaration_required = models.BooleanField(default=False)

    def __str__(self):
        return "AppConfig"

    class Meta:
        verbose_name = 'AppConfig'
        verbose_name_plural = 'AppConfig'


class Topic(models.Model):

    name = models.CharField(max_length=200, unique=True)

    def shorten_name(self):
        if len(self.name) <= 21:
            return self.name
        else:
            return self.name[:20]+"..."

    def __str__(self):
        return self.name

    def no_questions(self):
        return len(Problem.objects.filter(topics__in=[self]).distinct())

    class Meta:
        verbose_name = 'Topic'
        verbose_name_plural = 'Topics'


class Problem(models.Model):

    image = models.ImageField(upload_to=settings.IMAGE_UPLOAD_PATH, null=True, blank=True)

    video = models.TextField(null=True, blank=True)

    pdf = models.TextField(null=True, blank=True)

    graph_url = models.TextField(null=True, blank=True)

    description = RichTextField()

    solution = models.TextField(blank=True, null=True)

    hint = RichTextField(blank=True)

    answer = models.CharField(max_length=2000, blank=True)

    options = models.CharField(max_length=2000, blank=True)

    correct_options = models.CharField(max_length=2000, blank=True)

    category = models.CharField(max_length=1,
                                null=False,
                                blank=False,
                                choices=PROBLEM_CATEGORY_CHOICES)

    typed_by = models.ForeignKey('EasyHireApp.Administrator', on_delete=models.SET_NULL, null=True)

    difficulty = models.CharField(max_length=1,
                                  null=False,
                                  blank=False,
                                  choices=DIFFICULTY_CHOICES)

    topics = models.ManyToManyField(Topic, blank=True)

    date = models.DateField(auto_now=True)

    total_attempts = models.IntegerField(default=0)

    correct_attempts = models.IntegerField(default=0)

    text_to_speech = models.BooleanField(default=False)

    class Meta:
        verbose_name = 'Problem'
        verbose_name_plural = 'Problems'
        ordering = ['-id']

    def __str__(self):
        return self.description[:30]

    def get_shorten_description(self):
        return self.description[:70]

    def get_option_list(self):
        option_list = self.options.split("|")
        updated_option_list = [
            option for option in option_list if option != ""]
        return updated_option_list

    def get_correct_option_list(self):
        option_list = self.correct_options.split("|")
        updated_option_list = [
            option for option in option_list if option != ""]
        return updated_option_list

    def get_video_url_list(self):
        video_url_list = []
        try:
            video_url_list = json.loads(self.video)["items"]
        except Exception as e:
            pass
        return video_url_list

    def get_graph_url_list(self):
        try:
            urls = json.loads(self.graph_url)["items"]
            return urls
        except Exception as e:
            return []

    def clear_problem_topics(self):
        return self.topics.clear()


class Quiz(models.Model):

    title = models.CharField(max_length=100, null=False)

    instruction = RichTextField()

    uuid = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)

    def __str__(self):
        return self.title

    def save(self, *args, **kwargs):
        super(Quiz, self).save(*args, **kwargs)

    def get_shorten_quiz_instruction(self):
        return str(self.instruction.encode("ascii", errors="ignore")[:100])+"..."

    def get_topic_list(self):
        quiz_section_objs = QuizSection.objects.filter(quiz=self)
        topic_list = [
            quiz_section_obj.topic for quiz_section_obj in quiz_section_objs]
        return topic_list

    def total_sections(self):
        return len(QuizSection.objects.filter(quiz=self))

    def total_quiz_time(self):
        quiz_section_objs = QuizSection.objects.filter(quiz=self)
        total_time = 0
        for quiz_section_obj in quiz_section_objs:
            total_time += quiz_section_obj.time
        return total_time

    def total_no_of_questions(self):
        quiz_section_objs = QuizSection.objects.filter(quiz=self)
        total_questions = 0
        for quiz_section_obj in quiz_section_objs:
            total_questions += quiz_section_obj.no_questions
        return total_questions
    class Meta:
        verbose_name = 'Quiz'
        verbose_name_plural = 'Quizes'


class QuizSection(models.Model):

    quiz = models.ForeignKey(Quiz, on_delete=models.CASCADE)

    topic = models.ForeignKey(Topic, on_delete=models.CASCADE)

    no_questions = models.IntegerField(default=0)

    time = models.IntegerField(default=0)

    weightage = models.IntegerField(default=0)

    def __str__(self):
        return self.topic.name + " - " + self.quiz.title

    class Meta:
        verbose_name = 'QuizSection'
        verbose_name_plural = 'QuizSection'


class ProblemAttempted(models.Model):

    quiz_section = models.ForeignKey(QuizSection, on_delete=models.CASCADE, null=True)

    applicant = models.ForeignKey('EasyHireApp.Applicant', on_delete=models.CASCADE)

    problem = models.ForeignKey(Problem, on_delete=models.CASCADE)

    answer = models.TextField(null=True, blank=True)

    options = models.CharField(max_length=1000, null=True, blank=True)

    # text_analysis = models.TextField(null=True, blank=True)

    video_url = models.CharField(max_length=200, null=True, blank=True)

    def __str__(self):
        return self.applicant.name + " - " + self.quiz_section.quiz.title + " - " + self.quiz_section.topic.name

    def get_attempted_option_list(self):
        if self.options == None or self.options == "":
            return []
        option_list = self.options.split("|")
        updated_option_list = [
            option for option in option_list if option != ""]
        return updated_option_list

    # def generate_text_analysis(self):
    #     text_analysis = {}
    #     text_analysis["tone_analysis"] = get_tone_analysis(self.answer)
    #     text_analysis["personality_insights"] = get_text_personality_insights(self.answer)
    #     json_data = get_text_analysis(self.answer)
    #     if json_data["result"] == "success":
    #         score_id = json_data["score_id"]
    #         highlighted_text_json = get_highlighted_text(score_id)
    #         json_data["highlighted_text_json"] = highlighted_text_json

    #     text_analysis["text_analysis"] = json_data
    #     self.text_analysis = json.dumps(text_analysis)
    #     self.save()

    def is_selected_option_correct(self):

        if self.problem.category == PROBLEM_CATEGORY_DESCRIPTIVE:
            return True

        if self.problem.category == PROBLEM_CATEGORY_AUDIO:
            return True

        if self.problem.category == PROBLEM_CATEGORY_VIDEO:
            return True

        correct_choices = self.problem.get_correct_option_list()

        if len(correct_choices) == 0:
            return False

        attempted_options = self.get_attempted_option_list()

        if len(attempted_options) == 0:
            return False

        updated_attempted_options = [option.lower()
                                     for option in attempted_options]

        for correct_choice in correct_choices:
            lower_correct_choice = correct_choice.lower()
            if lower_correct_choice not in updated_attempted_options:
                return False
        return True

    # def get_applicant_tone_analysis(self):
    #     try:
    #         text_analysis = json.loads(self.text_analysis)
    #         return text_analysis["tone_analysis"]
    #     except Exception as e:
    #         return {}

    # def get_applicant_personality_insights(self):
    #     try:
    #         text_analysis = json.loads(self.text_analysis)
    #         return text_analysis["personality_insights"]
    #     except Exception as e:
    #         return {}

    class Meta:
        verbose_name = 'ProblemAttempted'
        verbose_name_plural = 'ProblemAttempted'


class QuizSectionResult(models.Model):

    quiz_section = models.ForeignKey(
        QuizSection, on_delete=models.SET_NULL, null=True)

    applicant = models.ForeignKey('EasyHireApp.Applicant', on_delete=models.CASCADE, null=True)

    no_question_attempted = models.IntegerField(default=0)

    calibration = models.FloatField(default=0.0)

    used_difficulties = models.FloatField(default=0.0)

    right_answers = models.IntegerField(default=0)

    datetime = models.DateTimeField(default=timezone.now)

    is_completed = models.BooleanField(default=False)

    observations = models.TextField(default="{\"calibration_list\":[]}")

    def get_attempted_problem_list(self):
        try:
            attempted_problem_obj_list = ProblemAttempted.objects.filter(applicant=self.applicant,
                                                                         quiz_section=self.quiz_section)
            problem_obj_list = []
            for attempted_problem in attempted_problem_obj_list:
                problem_obj_list.append(attempted_problem.problem)
            return problem_obj_list
        except Exception as e:
            print("get_attempted_problem_list: ", e)
            return []

    def __str__(self):
        try:
            return self.applicant.name + " - " + self.quiz_section.quiz.title + " - " + self.quiz_section.topic.name
        except Exception as e:
            return "None"


class QuizStatus(models.Model):

    applicant = models.ForeignKey(
        'EasyHireApp.Applicant', on_delete=models.CASCADE)

    quiz = models.ForeignKey(Quiz, on_delete=models.CASCADE)

    quiz_start_time = models.DateTimeField(null=True, blank=True)

    quiz_end_time = models.DateTimeField(null=True, blank=True)

    time_remaining = models.IntegerField(null=True, blank=True)

    def __str__(self):
        return self.applicant.name + " - " + self.quiz.title

    def is_allowed_to_take_quiz(self):

        if self.quiz_start_time == None or self.quiz_end_time == None:
            return True

        current_time = datetime.datetime.now()
        ez = pytz.timezone(settings.TIME_ZONE)
        current_time = ez.localize(current_time)

        if current_time >= self.quiz_start_time and current_time <= self.quiz_end_time:
            return True
        else:
            return False

    def get_attempted_descriptive_problem(self):
        attempted_problem_obj_list = ProblemAttempted.objects.filter(quiz_section__quiz=self.quiz,
                                                                     applicant=self.applicant,
                                                                     problem__category=PROBLEM_CATEGORY_DESCRIPTIVE)
        return attempted_problem_obj_list

    class Meta:
        verbose_name = 'QuizStatus'
        verbose_name_plural = 'QuizStatus'


class QuizResult(models.Model):

    applicant = models.ForeignKey(
        'EasyHireApp.Applicant', on_delete=models.CASCADE)

    quiz = models.ForeignKey(Quiz, on_delete=models.CASCADE)

    result = models.TextField(null=True, blank=True)

    def __str__(self):
        return self.applicant.name + " - " + self.quiz.title

    def get_applicant_score(self):
        applicant_total_score = 0
        try:
            applicant_total_score = json.loads(self.result)["applicant_total_score"]
        except Exception as e:
            pass
        return applicant_total_score

    def get_applicant_percentile(self):
        applicant_obj_list = []
        same_score = 0
        less_score = 0

        applicant_score = self.get_applicant_score()
        quiz_results = QuizResult.objects.filter(
            quiz=self.quiz).filter(~Q(applicant=self.applicant))
        for quiz_result in quiz_results:
            other_applicant_score = quiz_result.get_applicant_score()
            if quiz_result.applicant not in applicant_obj_list:
                if other_applicant_score == applicant_score:
                    same_score += 1
                elif other_applicant_score < applicant_score:
                    less_score += 1
                applicant_obj_list.append(quiz_result.applicant)

        total_applicant = len(applicant_obj_list)
        if total_applicant == 0:
            return 100

        percentile = ((less_score+(0.5*same_score))*100)/float(total_applicant)
        return round(percentile, 2)

    def generate_quiz_result(self):
        applicant_total_score = 0
        quiz_sections = QuizSection.objects.filter(quiz=self.quiz)
        total_quiz_sections = len(quiz_sections)
        quiz_section_result_list = []
        for quiz_section in quiz_sections:

            quiz_section_result_obj = QuizSectionResult.objects.get(applicant=self.applicant,
                                                                    quiz_section=quiz_section)

            attempted_problem_objs = ProblemAttempted.objects.filter(applicant=self.applicant,
                                                                     quiz_section=quiz_section)
            attempts = {
                "easy": 0,
                "medium": 0,
                "hard": 0,
                "total": 0
            }

            correct = {
                "easy": 0,
                "medium": 0,
                "hard": 0,
                "total": 0
            }

            total_easy = 0
            total_medium = 0
            total_hard = 0

            for attempted_problem_obj in attempted_problem_objs:

                if attempted_problem_obj.problem.difficulty == DIFFICULTY_EASY:
                    attempts["easy"] += 1
                    if attempted_problem_obj.is_selected_option_correct():
                        correct["easy"] += 1
                        correct["total"] += 1

                elif attempted_problem_obj.problem.difficulty == DIFFICULTY_MEDIUM:
                    attempts["medium"] += 1
                    if attempted_problem_obj.is_selected_option_correct():
                        correct["medium"] += 1
                        correct["total"] += 1
                else:
                    attempts["hard"] += 1
                    if attempted_problem_obj.is_selected_option_correct():
                        correct["hard"] += 1
                        correct["total"] += 1

                attempts["total"] += 1

            abs_easy = 0
            if attempts["easy"] != 0:
                abs_easy = round(correct["easy"]/attempts["easy"]*100, 2)

            abs_medium = 0
            if attempts["medium"] != 0:
                abs_medium = round(correct["medium"]/attempts["medium"]*100, 2)

            abs_hard = 0
            if attempts["hard"] != 0:
                abs_hard = round(correct["hard"]/attempts["hard"]*100, 2)

            total_abs_per = 0
            if attempts["total"] != 0:
                total_abs_per = round(
                    correct["total"]/attempts["total"]*100, 2)

            abs_per = {
                "easy": abs_easy,
                "medium": abs_medium,
                "hard": abs_hard,
                "total": total_abs_per,
            }

            pass_score = 1*attempts["easy"]+2 * \
                attempts["medium"]+3*attempts["hard"]
            adjusted_diff_score = 1*correct["easy"] + \
                2*correct["medium"]+3*correct["hard"]

            temp_dict = {
                "id": quiz_section.pk,
                "section_name": quiz_section.topic.name,
                "is_completed": quiz_section_result_obj.is_completed,
                "total_questions": quiz_section.no_questions,
                "no_questions_attempted": attempts["total"],
                "right_answers": correct["total"],
                "attempts": attempts,
                "correct": correct,
                "abs_per": abs_per,
                "total_abs_per": total_abs_per,
                "pass_score": (pass_score*0.6),
                "adjusted_diff_score": adjusted_diff_score,
                "diff_score": round(adjusted_diff_score*100/pass_score, 2)
            }

            applicant_total_score += total_abs_per
            quiz_section_result_list.append(temp_dict)

        applicant_total_score = round(
            applicant_total_score/total_quiz_sections, 2)
        self.result = json.dumps({
            "applicant_total_score": applicant_total_score,
            "quiz_section_result_list": quiz_section_result_list
        })
        self.save()

    class Meta:
        verbose_name = 'QuizResult'
        verbose_name_plural = 'QuizResult'
